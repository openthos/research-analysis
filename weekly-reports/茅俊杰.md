# 2017.5.22 - 2017.5.26

1. Categorical construction of structures
   1. Some insights that are helpful in building a categorical description of structures.
	  1. A category acts like a type in PL, where the objects in that category is all valid values of the type.
	  1. A (categorical) functor acts like a function, and the category of functors from **C** to **D** is like a function type C->D in PL. Such categories are cocomplete iff **D** is cocomplete.
	  1. Given a category **C**, a functor **1** -> **C** is exactly an object in **C**, which means the category of such functors is isomorphic to **C**.
	  1. As a result, a structure consisting of some values and some functions can be viewed as a collection of functors, which is exactly the n-product category of the categories representing the fields. This category is cocomplete if all the fields are cocomplete.
   1. A DSL is introduced to describe such structures and parsed to OCaml code implementing that structure using cocomplete categories. The DSL currently bases on YAML. See tests/mod.yaml in git@enight.me:enight/ocats.git for an example which implements the single-refcount merge in RID.
1. Out-of-tree modules in Android-x86 kernel
   1. Write a script that locates potential mainline commits that change APIs used by a given module. See git@enight.me:seda/seda.git:libexec/collateral-locate for details.
   1. Four drivers are introduced during the development from v4.7 to v4.12rc1, namely broadcom sta, rtl8812au and rtl8723b[s|u]. There are three related API-changing commits, namely 174cd4b1e5fb, ca986ad9bcd3 and 29ce6ecbb83c.
      1. 174cd4b1e5fb: add a header inclusion. The pattern can be inferred as long as the header-inclusion-related part in SeDA is enhanced.
	  1. ca986ad9bcd3: replace a flag set with an update to another field. Can be inferred by SeDA.
      1. 29ce6ecbb83c: pack most arguments of cfg80211_roamed() into a structure. This is a multiple-line change with some slight differentces among the change instances. The pattern cannot yet be inferred by SeDA.

Next week:

1. Implement a menhir-based parser for the introduced DSL so that more maintenance code are generated instead of hard-coded.
1. Take a look at the upate history of linux-rt.

# 2017.5.15 - 2017.5.19

1. Encoding functor categories and their colimits in OCaml. Though it is useful when constructing schemas, it requires that all fields in a schema contain values from the same category, which does not apply to RID or SeDA since different fields in a structure should be combined in different ways and are thus should be picked from different categories.
1. Skim materials on adjunctions. Though adjunctions provide a general way of characterizing many constructs in different fields, it is mostly conceptual and has little general constructive processes, which is not yet suitable for the current project.
1. Search for more papers on applying category theory in computation.
   1. A Categorical Programming Language (1993), which defines a language in which data types are solely categorical constructs (mainly adjunctions). It is mainly focused on primitive types and how known operations can be expressed in a categorical way.
   1. A DSEL for Computational Category Theory (2010), which is another attempt in coding basic categorical constructs (in Lisp).
   1. Graph Transformation by Computational Category Theory (2010), which implements colimits of labeled graphs (in Java).
   1. Computability and Complexity of Categorical Structures (2015), which proves that a language with functor composition, Kan extension and Kan lifting is strictly stronger than a Turing Machine.
1. Look into the lazy_purge issue of llvmlinux-4.7-rc1. The root cause is that: (from comments in the function isGEPKnownNonNull in lib/Analysis/ValueTracking.cpp)

> // Walk the GEP operands and see if any operand introduces a non-zero offset.
> // If so, then the GEP cannot produce a null pointer, as doing so would
> // inherently violate the inbounds contract within address space zero.

   which means that an expression of the form (&A->f) is considered non-null in LLVM if f is not the first field of A. As a result, (&A->f != NULL) is optimized to (true). LLVM should not be blamed, however, because it is Linux who assumes underflow integers are wrapped around in two's complement notation and uses such assumption for finding the end of a linked list, while integer underflow gives undefined behavior according to the C specification. The current work around is to replace (&A->f != NULL) with (A != container_of(NULL, typeof(*A), f)) to get rid of any GEP expression or NULL-checks.

Next week:

1. Try constructing a category of labelled graphs in which each label comes from a different category, and check if the algorithm under SeDA can be expressed as an analysis on the colimits in such category.
1. Take a look at the update history of the Android kernel, look for the mainline commits that affects Android-specific drivers and try inferring them using SeDA.

# 2017.5.8 - 2017.5.12

1. Skim Chapter 8, Computational Category Theory, which regards calculating term unifications as constructing coequalizers in the Kleisli Category and illustrates how coequalizers can be recursively constructed in any cocomplete categories. This approach is likely to apply to the graph unification problem, which is linked to what SeDA tries to solve, but has little relations to RID.
1. Go through the first first 3 sections in Chapter 5, Computational Category Theory, and encoding the construction of Comma Category and its colimits in OCaml. Comma categories provide a way to label other structures. The path summaries in RID can then be described as the power lattice of formulas labeled with a set of integers (also a lattice) for each reference counter, while the change graphs in SeDA are graphs labeled with AST attributes and operations like add/delete/keep.
1. Look into the boot failure of llvmlinux-4.7-rc1. The patch that works around a clang optimization bug is attached in the repo (See developers/).

Next week:

1. Read and encoding the functor category which is another way of constructing new cocomplete categories from known ones, and study if it is usable in the description of RID, SeDA, spdiff, MVICFG, etc.

# 2017.5.1 - 2017.5.5

1. Read through Chapter 4, Computational Category Theory, understand the theorem stating the existence of colimits and program the construction in OCaml.

Next week:

1. Study the categorial unification algorithm proposed in Chapter 8 in the book (it depends solely on the first four chapters) as well as the 'graph unification' problem which is at the core of both spdiff and SeDA.
1. Come up with a categorial representation of structures used in the analysis of RID.

# 2017.4.24 - 2017.4.28

1. Set up an OCaml project hosting a computational representation of basic constructions in Category Theory (see git@enight.me:enight/ocats.git for details), and implement the basic concepts presented in Chapter 3, Computational Category Theory using OCaml modules.
1. Arrange the patchset which adapts Linux to Clang.
1. Update README in seda.

Next week:

1. Implement the exercises in Chapter 3 as well as limits & colimits which are the main topic of Chapter 4 in the book. Both of those will be used in the final Ph.D thesis.

>> chyyuu: 到4月21日，属于特殊阶段，研究进展和撰写论文等很不错。后续，我们回到正常步骤，希望能进一步完善和提炼博士课题。

# 2017.2.20 - 2017.2.24

Add mathematical contents in the paper (refer to git@enight.me:seda/paper.git for details).

Next week: Start filling the technical parts, both with data (if now available)
and detailed descriptions.

>> chy: Good, and you can send tasks to Li dong, cc me.

# 2017.2.27 - 2017.3.3

1. Collect various characteristics of the previously selected patches, and put them into the paper.
1. Add a background section to the paper. An example that will be discussed throughout the paper is also added.
1. Fix various bugs in unit tests, PDG isomorphism, pattern extraction, etc.
1. Attend several discussions on the seda project.

Next week: Motivate the techniques we adopt by the empirical study, and use the example introduced this week to make the technical parts concrete. Also add some related work if there is time.

# 2017.3.5 - 2017.3.10

1. Add data of the empirical study into the paper
1. Explain macro-annotated AST and change untangling using the example given in Section 2.

Next week: Go back to the code to deal with context-related stuff and complex changes.

# 2017.3.13 - 2017.3.17

1. Some enhancements to SeDA:
  * Fix matching of PDG function arguments
  * Also analyze files using any changed functions (except direct calls)
  * Consider functions passed as function arguments as another kind of context.
  * Disable the costly pre-process which involves IPA but is useless in the current scenario. As a result, the limit of functions analyzed for a single commit is raised from 15 to 25.
  * Infer inclusion changes.
  * Fix PDG alignment and AST pattern extraction.
  * Adjust PDG/CDG pattern merging.

  To summarize, 11 out of 13 commits involving callbacks now have sufficient information for the cocci backend.

Next week: Go back to the paper and prepare a slide for presentation.

# 2017.3.20 - 2017.3.24

1. Make a draft slide on SeDA and present it in the group.
2. Go over the related research fields, namely patch inference (both empirical studies and techniques), automated refactoring and clone detection, and fill in the related work section in the paper.
3. Fix a few reported bugs in the SeDA code.

Next week: Go back to the code, try a simpler-to-explain way of untangling, grouping and abstraction, and start collecting evaluation results for the paper.

# 2017.3.27 - 2017.3.31

1. The new grouping, abstraction and coccigen purely based on AST can now handle ~40% commits which contains 1/3+ patterns. The tool will be further enhanced in the next few days to see if it can achieve >70%.

Next week: Collect evaluation results as proposed in the slides and prepare for the presentation.
